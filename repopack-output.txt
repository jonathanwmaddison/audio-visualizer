================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-29T17:04:44.395Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
app/
  favicon.ico
  globals.css
  layout.tsx
  page.tsx
components/
  AudioVisualizer.tsx
  ParticleConstellationVisualizer.ts
  QuantumRippleVisualizer.ts
  RainbowSquarePulseVisualizer.ts
  SynapticNetworkVisualizer.tsx
  Visualizer.ts
public/
  next.svg
  vercel.svg
.eslintrc.json
.gitignore
next.config.mjs
package.json
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

body {
  background-color: #1a202c;
  color: white;
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

================
File: app/page.tsx
================
import AudioVisualizer from '../components/AudioVisualizer';

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <div className="z-10 w-full max-w-5xl items-center justify-between font-mono text-sm">
        <h1 className="text-4xl font-bold mb-8 text-center">Retro Audio Visualizer</h1>
        <AudioVisualizer />
      </div>
    </main>
  );
}

================
File: components/AudioVisualizer.tsx
================
'use client';

import React, { useEffect, useRef, useState } from 'react';
import { Sliders, Play, Pause, Maximize, Minimize } from 'lucide-react';
import { ParticleConstellationVisualizer } from './ParticleConstellationVisualizer';
import { SynapticNetworkVisualizer } from './SynapticNetworkVisualizer';
import { RainbowSquarePulseVisualizer } from './RainbowSquarePulseVisualizer';
import { QuantumRippleVisualizer } from './QuantumRippleVisualizer';
import { Visualizer } from './Visualizer';

type VisualizationType = 'bars' | 'wave' | 'circular' | 'constellation' | 'synaptic' | 'rainbowSquare' | 'quantumRipple';

const AudioVisualizer: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [audioContext, setAudioContext] = useState<AudioContext | null>(null);
  const [analyser, setAnalyser] = useState<AnalyserNode | null>(null);
  const [dataArray, setDataArray] = useState<Uint8Array | null>(null);
  const [isRecording, setIsRecording] = useState<boolean>(false);
  const [visualizationType, setVisualizationType] = useState<VisualizationType>('quantumRipple');
  const [sensitivity, setSensitivity] = useState<number>(1.5);
  const [currentVisualizer, setCurrentVisualizer] = useState<Visualizer | null>(null);
  const [isFullscreen, setIsFullscreen] = useState<boolean>(false);

  useEffect(() => {
    if (canvasRef.current) {
      const ctx = canvasRef.current.getContext('2d');
      if (ctx) {
        switch (visualizationType) {
          case 'constellation':
            setCurrentVisualizer(new ParticleConstellationVisualizer(ctx, canvasRef.current.width, canvasRef.current.height));
            break;
          case 'synaptic':
            setCurrentVisualizer(new SynapticNetworkVisualizer(ctx, canvasRef.current.width, canvasRef.current.height));
            break;
          case 'rainbowSquare':
            setCurrentVisualizer(new RainbowSquarePulseVisualizer(ctx, canvasRef.current.width, canvasRef.current.height));
            break;
          case 'quantumRipple':
            setCurrentVisualizer(new QuantumRippleVisualizer(ctx, canvasRef.current.width, canvasRef.current.height));
            break;
          default:
            setCurrentVisualizer(null);
        }
      }
    }
  }, [visualizationType]);
  useEffect(() => {
    const handleResize = () => {
      if (canvasRef.current && containerRef.current) {
        canvasRef.current.width = containerRef.current.clientWidth;
        canvasRef.current.height = containerRef.current.clientHeight;
        const ctx = canvasRef.current.getContext('2d');
        if (ctx && currentVisualizer) {
          if (currentVisualizer instanceof ParticleConstellationVisualizer) {
            setCurrentVisualizer(new ParticleConstellationVisualizer(ctx, canvasRef.current.width, canvasRef.current.height));
          } else if (currentVisualizer instanceof SynapticNetworkVisualizer) {
            setCurrentVisualizer(new SynapticNetworkVisualizer(ctx, canvasRef.current.width, canvasRef.current.height));
          } else if (currentVisualizer instanceof RainbowSquarePulseVisualizer) {
            setCurrentVisualizer(new RainbowSquarePulseVisualizer(ctx, canvasRef.current.width, canvasRef.current.height));
          }
        }
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [currentVisualizer]);

  useEffect(() => {
    if (typeof window !== 'undefined' && isRecording && canvasRef.current && analyser && dataArray) {
      const ctx = canvasRef.current.getContext('2d');
      if (!ctx) return;

      const draw = () => {
        requestAnimationFrame(draw);
        const canvas = canvasRef.current;
        if (!canvas) return;

        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        analyser.getByteFrequencyData(dataArray);

        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // Increased trail effect
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        if (currentVisualizer) {
          currentVisualizer.draw(dataArray, sensitivity);
        } else {
          switch (visualizationType) {
            case 'bars':
              drawBars(ctx, WIDTH, HEIGHT, dataArray);
              break;
            case 'wave':
              drawWave(ctx, WIDTH, HEIGHT, dataArray);
              break;
            case 'circular':
              drawCircular(ctx, WIDTH, HEIGHT, dataArray);
              break;
          }
        }
      };
      draw();
    }
  }, [isRecording, analyser, dataArray, visualizationType, sensitivity, currentVisualizer]);

  const drawBars = (ctx: CanvasRenderingContext2D, WIDTH: number, HEIGHT: number, dataArray: Uint8Array) => {
    const barWidth = (WIDTH / dataArray.length) * 2.5;
    let x = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const barHeight = (dataArray[i] / 255) * HEIGHT * sensitivity;
      const r = barHeight + 25 * (i / dataArray.length);
      const g = 250 * (i / dataArray.length);
      const b = 50;
      ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
      ctx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);
      x += barWidth + 1;
    }
  };

  const drawWave = (ctx: CanvasRenderingContext2D, WIDTH: number, HEIGHT: number, dataArray: Uint8Array) => {
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgb(0, 255, 0)';
    const sliceWidth = WIDTH * 1.0 / dataArray.length;
    let x = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const v = (dataArray[i] / 128.0) * sensitivity;
      const y = v * HEIGHT / 2;
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
      x += sliceWidth;
    }
    ctx.lineTo(WIDTH, HEIGHT / 2);
    ctx.stroke();
  };

  const drawCircular = (ctx: CanvasRenderingContext2D, WIDTH: number, HEIGHT: number, dataArray: Uint8Array) => {
    const center_x = WIDTH / 2;
    const center_y = HEIGHT / 2;
    const radius = Math.min(WIDTH, HEIGHT) / 3;
    
    ctx.beginPath();
    ctx.arc(center_x, center_y, radius, 0, 2 * Math.PI);
    ctx.strokeStyle = 'rgb(0, 255, 0)';
    ctx.stroke();

    for (let i = 0; i < dataArray.length; i++) {
      const rads = Math.PI * 2 / dataArray.length;
      const bar_height = (dataArray[i] / 255) * radius * sensitivity;
      const x = center_x + Math.cos(rads * i) * (radius);
      const y = center_y + Math.sin(rads * i) * (radius);
      const x_end = center_x + Math.cos(rads * i) * (radius + bar_height);
      const y_end = center_y + Math.sin(rads * i) * (radius + bar_height);
      
      ctx.beginPath();
      ctx.strokeStyle = `hsl(${i / dataArray.length * 360}, 100%, 50%)`;
      ctx.moveTo(x, y);
      ctx.lineTo(x_end, y_end);
      ctx.stroke();
    }
  };

  const startRecording = async () => {
    const audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
    const analyserNode = audioCtx.createAnalyser();
    analyserNode.fftSize = 1024; // Increased for more detailed data
    analyserNode.minDecibels = -90; // Increased sensitivity to quieter sounds
    analyserNode.maxDecibels = -10;
    analyserNode.smoothingTimeConstant = 0.85;

    const bufferLength = analyserNode.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const source = audioCtx.createMediaStreamSource(stream);
      source.connect(analyserNode);

      setAudioContext(audioCtx);
      setAnalyser(analyserNode);
      setDataArray(dataArray);
      setIsRecording(true);
    } catch (err) {
      console.error('Error accessing microphone:', err);
    }
  };

  const stopRecording = () => {
    if (audioContext) {
      audioContext.close();
    }
    setIsRecording(false);
    setAudioContext(null);
    setAnalyser(null);
    setDataArray(null);
  };

  const handleCanvasClick = (event: React.MouseEvent<HTMLCanvasElement>) => {
    if (currentVisualizer instanceof SynapticNetworkVisualizer) {
      const rect = canvasRef.current!.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      currentVisualizer.handleInteraction(x, y);
    }
  };

  const toggleFullscreen = () => {
    if (!isFullscreen) {
      if (containerRef.current?.requestFullscreen) {
        containerRef.current.requestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
    setIsFullscreen(!isFullscreen);
  };

  return (
    <div 
      ref={containerRef} 
      className={`flex flex-col items-center justify-center ${isFullscreen ? 'fixed inset-0 z-50 bg-black' : 'min-h-screen bg-gray-800'}`}
    >
      <canvas 
        ref={canvasRef} 
        width={800} 
        height={400} 
        className={`bg-black mb-4 rounded ${isFullscreen ? 'w-full h-full' : ''}`}
        onClick={handleCanvasClick}
      />
      <div className={`flex space-x-4 mb-4 ${isFullscreen ? 'absolute bottom-4' : ''}`}>
        <button
          onClick={isRecording ? stopRecording : startRecording}
          className={`flex items-center px-4 py-2 rounded ${
            isRecording ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'
          }`}
        >
          {isRecording ? <Pause className="mr-2" /> : <Play className="mr-2" />}
          {isRecording ? 'Stop' : 'Start'}
        </button>
        <select
          value={visualizationType}
          onChange={(e) => setVisualizationType(e.target.value as VisualizationType)}
          className="bg-gray-700 rounded px-2 py-1"
        >
          <option value="bars">Bars</option>
          <option value="wave">Wave</option>
          <option value="circular">Circular</option>
          <option value="constellation">Constellation</option>
          <option value="synaptic">Synaptic Network</option>
          <option value="rainbowSquare">Rainbow Square</option>
          <option value="quantumRipple">Quantum Ripple</option>
        </select>
        <div className="flex items-center">
          <Sliders className="mr-2" />
          <input
            type="range"
            min={0.5}
            max={4}
            step={0.1}
            value={sensitivity}
            onChange={(e) => setSensitivity(parseFloat(e.target.value))}
            className="w-32"
          />
        </div>
        <button
          onClick={toggleFullscreen}
          className="flex items-center px-4 py-2 rounded bg-blue-500 hover:bg-blue-600"
        >
          {isFullscreen ? <Minimize className="mr-2" /> : <Maximize className="mr-2" />}
          {isFullscreen ? 'Exit Fullscreen' : 'Fullscreen'}
        </button>
      </div>
    </div>
  );
};

export default AudioVisualizer;

================
File: components/ParticleConstellationVisualizer.ts
================
import { Visualizer } from './Visualizer';

interface Particle {
  x: number;
  y: number;
  size: number;
  color: string;
  speed: number;
}

export class ParticleConstellationVisualizer implements Visualizer {
  private ctx: CanvasRenderingContext2D;
  private width: number;
  private height: number;
  private particles: Particle[];
  private readonly particleCount = 100;
  private readonly connectionDistance = 100;

  constructor(ctx: CanvasRenderingContext2D, width: number, height: number) {
    this.ctx = ctx;
    this.width = width;
    this.height = height;
    this.particles = this.createParticles();
  }

  private createParticles(): Particle[] {
    return Array.from({ length: this.particleCount }, () => ({
      x: Math.random() * this.width,
      y: Math.random() * this.height,
      size: Math.random() * 2 + 1,
      color: `hsl(${Math.random() * 360}, 50%, 50%)`,
      speed: Math.random() * 0.5 + 0.1
    }));
  }

  private updateParticles(audioData: Uint8Array): void {
    this.particles.forEach((particle, index) => {
      // Move particle
      particle.y -= particle.speed;
      
      // Reset particle if it moves off screen
      if (particle.y < 0) {
        particle.y = this.height;
        particle.x = Math.random() * this.width;
      }

      // Update particle based on audio data
      const audioIndex = Math.floor(index / this.particles.length * audioData.length);
      particle.size = (audioData[audioIndex] / 255) * 3 + 1;
      particle.color = `hsl(${audioData[audioIndex]}, 50%, 50%)`;
    });
  }

  private drawParticles(): void {
    this.particles.forEach(particle => {
      this.ctx.beginPath();
      this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      this.ctx.fillStyle = particle.color;
      this.ctx.fill();
    });
  }

  private drawConnections(): void {
    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    this.ctx.lineWidth = 0.5;

    for (let i = 0; i < this.particles.length; i++) {
      for (let j = i + 1; j < this.particles.length; j++) {
        const dx = this.particles[i].x - this.particles[j].x;
        const dy = this.particles[i].y - this.particles[j].y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < this.connectionDistance) {
          this.ctx.beginPath();
          this.ctx.moveTo(this.particles[i].x, this.particles[i].y);
          this.ctx.lineTo(this.particles[j].x, this.particles[j].y);
          this.ctx.stroke();
        }
      }
    }
  }

  draw(audioData: Uint8Array): void {
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    this.ctx.fillRect(0, 0, this.width, this.height);

    this.updateParticles(audioData);
    this.drawConnections();
    this.drawParticles();
  }
}

================
File: components/QuantumRippleVisualizer.ts
================
import { Visualizer } from './Visualizer';

interface Particle {
  x: number;
  y: number;
  amplitude: number;
  phase: number;
  frequency: number;
}

export class QuantumRippleVisualizer implements Visualizer {
  private ctx: CanvasRenderingContext2D;
  private width: number;
  private height: number;
  private particles: Particle[];
  private time: number;

  constructor(ctx: CanvasRenderingContext2D, width: number, height: number) {
    this.ctx = ctx;
    this.width = width;
    this.height = height;
    this.particles = this.initializeParticles();
    this.time = 0;
  }

  private initializeParticles(): Particle[] {
    const particles: Particle[] = [];
    const particleCount = 50;
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: Math.random() * this.width,
        y: Math.random() * this.height,
        amplitude: Math.random() * 20 + 10,
        phase: Math.random() * Math.PI * 2,
        frequency: Math.random() * 0.02 + 0.01
      });
    }
    return particles;
  }

  draw(audioData: Uint8Array, sensitivity: number): void {
    const ctx = this.ctx;
    const width = this.width;
    const height = this.height;

    // Clear the canvas with a fade effect
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, width, height);

    // Calculate average audio level
    const avgAudio = audioData.reduce((sum, val) => sum + val, 0) / audioData.length;
    const normalizedAudio = avgAudio / 255 * sensitivity;

    // Update and draw particles
    this.particles.forEach((particle, index) => {
      const audioIndex = Math.floor(index / this.particles.length * audioData.length);
      const audioValue = audioData[audioIndex] / 255 * sensitivity;

      particle.amplitude = 10 + audioValue * 40;
      particle.frequency = 0.01 + audioValue * 0.03;

      const waveX = Math.sin(this.time * particle.frequency + particle.phase) * particle.amplitude;
      const waveY = Math.cos(this.time * particle.frequency + particle.phase) * particle.amplitude;

      const x = (particle.x + waveX + width) % width;
      const y = (particle.y + waveY + height) % height;

      // Draw quantum particle
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, particle.amplitude);
      gradient.addColorStop(0, `hsla(${audioValue * 360}, 100%, 50%, 0.8)`);
      gradient.addColorStop(1, `hsla(${audioValue * 360}, 100%, 50%, 0)`);

      ctx.beginPath();
      ctx.arc(x, y, particle.amplitude, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
    });

    // Draw interference patterns
    ctx.globalCompositeOperation = 'screen';
    ctx.lineWidth = 2;
    for (let i = 0; i < this.particles.length; i++) {
      for (let j = i + 1; j < this.particles.length; j++) {
        const p1 = this.particles[i];
        const p2 = this.particles[j];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 100) {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.strokeStyle = `hsla(${normalizedAudio * 360}, 100%, 50%, ${1 - distance / 100})`;
          ctx.stroke();
        }
      }
    }
    ctx.globalCompositeOperation = 'source-over';

    this.time += 0.1;
  }
}

================
File: components/RainbowSquarePulseVisualizer.ts
================
import { Visualizer } from './Visualizer';

export class RainbowSquarePulseVisualizer implements Visualizer {
  private ctx: CanvasRenderingContext2D;
  private width: number;
  private height: number;
  private squareSize: number;
  private rainbowColors: string[];
  private currentColorIndex: number;
  private yPosition: number;
  private lastAudioLevel: number;

  constructor(ctx: CanvasRenderingContext2D, width: number, height: number) {
    this.ctx = ctx;
    this.width = width;
    this.height = height;
    this.squareSize = Math.min(width, height) / 4;
    this.rainbowColors = [
      '#FF0000', '#FF7F00', '#FFFF00', '#00FF00', 
      '#0000FF', '#4B0082', '#9400D3'
    ];
    this.currentColorIndex = 0;
    this.yPosition = height / 2;
    this.lastAudioLevel = 0;
  }

  draw(audioData: Uint8Array, sensitivity: number): void {
    const ctx = this.ctx;
    const width = this.width;
    const height = this.height;

    // Clear the canvas with a slight trail effect
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, width, height);

    // Calculate the average volume, focusing on lower frequencies
    const lowFreqData = audioData.slice(0, Math.floor(audioData.length / 3));
    const average = lowFreqData.reduce((sum, value) => sum + value, 0) / lowFreqData.length;
    
    // Apply sensitivity and smooth the audio level
    const audioLevel = (average / 255) * sensitivity;
    this.lastAudioLevel = this.lastAudioLevel * 0.8 + audioLevel * 0.2;

    // Determine the y position based on the volume
    const targetY = height - this.lastAudioLevel * height;
    this.yPosition += (targetY - this.yPosition) * 0.1; // Smooth movement

    // Calculate the size of the square based on the volume
    const basePulseSize = this.squareSize + (this.lastAudioLevel * this.squareSize);
    const pulseSize = basePulseSize + Math.sin(Date.now() / 200) * (basePulseSize * 0.1);

    // Draw rainbow trails
    for (let i = 5; i >= 0; i--) {
      const trailSize = pulseSize - i * 15;
      const trailAlpha = 1 - (i / 5);
      const colorIndex = (this.currentColorIndex - i + this.rainbowColors.length) % this.rainbowColors.length;
      ctx.fillStyle = this.hexToRGBA(this.rainbowColors[colorIndex], trailAlpha);
      ctx.fillRect(
        width / 2 - trailSize / 2,
        this.yPosition - trailSize / 2,
        trailSize,
        trailSize
      );
    }

    // Draw the main square
    ctx.fillStyle = this.rainbowColors[this.currentColorIndex];
    ctx.fillRect(
      width / 2 - pulseSize / 2,
      this.yPosition - pulseSize / 2,
      pulseSize,
      pulseSize
    );

    // Add a glow effect
    ctx.shadowBlur = 20;
    ctx.shadowColor = this.rainbowColors[this.currentColorIndex];
    ctx.strokeStyle = this.rainbowColors[this.currentColorIndex];
    ctx.lineWidth = 2;
    ctx.strokeRect(
      width / 2 - pulseSize / 2,
      this.yPosition - pulseSize / 2,
      pulseSize,
      pulseSize
    );
    ctx.shadowBlur = 0;

    // Cycle through colors based on audio intensity
    if (this.lastAudioLevel > 0.5) {
      this.currentColorIndex = (this.currentColorIndex + 1) % this.rainbowColors.length;
    }
  }

  private hexToRGBA(hex: string, alpha: number): string {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }
}

================
File: components/SynapticNetworkVisualizer.tsx
================
import { Visualizer } from './Visualizer';

interface Node {
  x: number;
  y: number;
  frequency: number;
  connections: number[];
  intensity: number;
}

export class SynapticNetworkVisualizer implements Visualizer {
  private ctx: CanvasRenderingContext2D;
  private width: number;
  private height: number;
  private nodes: Node[];
  private readonly nodeCount = 32; // Matches typical analyser.fftSize / 2
  private time: number = 0;

  constructor(ctx: CanvasRenderingContext2D, width: number, height: number) {
    this.ctx = ctx;
    this.width = width;
    this.height = height;
    this.nodes = this.createNodes();
  }

  private createNodes(): Node[] {
    const nodes: Node[] = [];
    for (let i = 0; i < this.nodeCount; i++) {
      nodes.push({
        x: Math.random() * this.width,
        y: Math.random() * this.height,
        frequency: i,
        connections: this.getRandomConnections(i),
        intensity: 0
      });
    }
    return nodes;
  }

  private getRandomConnections(index: number): number[] {
    const connections: number[] = [];
    const connectionCount = Math.floor(Math.random() * 3) + 1; // 1 to 3 connections
    for (let i = 0; i < connectionCount; i++) {
      let connection = Math.floor(Math.random() * this.nodeCount);
      while (connection === index || connections.includes(connection)) {
        connection = Math.floor(Math.random() * this.nodeCount);
      }
      connections.push(connection);
    }
    return connections;
  }

  private updateNodes(audioData: Uint8Array): void {
    this.nodes.forEach((node, index) => {
      node.intensity = audioData[index] / 255;
      
      // Move nodes based on their intensity and time
      const angle = (this.time + index) * 0.05;
      const distance = node.intensity * 2;
      node.x += Math.cos(angle) * distance;
      node.y += Math.sin(angle) * distance;

      // Keep nodes within bounds
      node.x = Math.max(0, Math.min(this.width, node.x));
      node.y = Math.max(0, Math.min(this.height, node.y));
    });
  }

  private drawNodes(): void {
    this.nodes.forEach(node => {
      const radius = node.intensity * 10 + 2;
      const hue = node.frequency * (360 / this.nodeCount);
      
      this.ctx.beginPath();
      this.ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
      this.ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${node.intensity})`;
      this.ctx.fill();
    });
  }

  private drawConnections(): void {
    this.nodes.forEach(node => {
      node.connections.forEach(connectionIndex => {
        const connectedNode = this.nodes[connectionIndex];
        const intensity = (node.intensity + connectedNode.intensity) / 2;
        
        this.ctx.beginPath();
        this.ctx.moveTo(node.x, node.y);
        this.ctx.lineTo(connectedNode.x, connectedNode.y);
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.5})`;
        this.ctx.lineWidth = intensity * 3;
        this.ctx.stroke();
      });
    });
  }

  draw(audioData: Uint8Array): void {
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    this.ctx.fillRect(0, 0, this.width, this.height);

    this.updateNodes(audioData);
    this.drawConnections();
    this.drawNodes();

    this.time += 0.1; // Increment time for animation
  }

  // Method to handle user interaction (e.g., clicking or dragging nodes)
  handleInteraction(x: number, y: number): void {
    // Find the closest node
    const closestNode = this.nodes.reduce((closest, node) => {
      const distance = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);
      return distance < closest.distance ? { node, distance } : closest;
    }, { node: null, distance: Infinity });

    if (closestNode.node && closestNode.distance < 20) {
      // Highlight the node and its connections
      closestNode.node.intensity = 1;
      closestNode.node.connections.forEach(index => {
        this.nodes[index].intensity = 1;
      });
    }
  }
}

================
File: components/Visualizer.ts
================
export interface Visualizer {
    draw(audioData: Uint8Array): void;
  }

================
File: public/next.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================
File: public/vercel.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>

================
File: .eslintrc.json
================
{
  "extends": "next/core-web-vitals"
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

================
File: package.json
================
{
  "name": "audio-visualizer",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "lucide-react": "^0.436.0",
    "next": "14.2.7",
    "react": "^18",
    "react-dom": "^18"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "14.2.7",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: README.md
================
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      backgroundImage: {
        "gradient-radial": "radial-gradient(var(--tw-gradient-stops))",
        "gradient-conic":
          "conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",
      },
    },
  },
  plugins: [],
};
export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
